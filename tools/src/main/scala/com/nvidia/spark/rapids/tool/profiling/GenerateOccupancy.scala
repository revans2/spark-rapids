/*
 * Copyright (c) 2021, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.nvidia.spark.rapids.tool.profiling

import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer

import com.nvidia.spark.rapids.tool.ToolTextFileWriter

import org.apache.spark.sql.rapids.tool.profiling.ApplicationInfo

case class OccupancyTaskInfo(stageId: Int, taskId: Long,
    launchTime: Long, finishTime: Long, duration: Long)

/**
 * Generates an SVG graph that is used to show cluster occupancy of tasks.
 */
object GenerateOccupancy {
  val TASK_HEIGHT = 100
  val HEADER_WIDTH = 200
  val PADDING = 5
  val FONT_SIZE = 14
  val TITLE_HEIGHT = FONT_SIZE + (PADDING * 2)
  val MS_PER_PIXEL = 1

  val colors = Array(
    "#696969",
    "#2e8b57",
    "#800000",
    "#191970",
    "#808000",
    "#ff0000",
    "#ff8c00",
    "#ffd700",
    "#0000cd",
    "#ba55d3",
    "#00ff7f",
    "#adff2f",
    "#ff00ff",
    "#1e90ff",
    "#fa8072",
    "#dda0dd",
    "#87ceeb",
    "#ff1493",
    "#f5deb3",
    "#7fffd4")

  def generateFor(app: ApplicationInfo, outputDirectory: String): Unit = {
    val hostToExecList = new mutable.TreeMap[String,
        mutable.TreeMap[String, ArrayBuffer[OccupancyTaskInfo]]]()
    val stageIdToColor = mutable.HashMap[Int, String]()
    var colorIndex = 0
    var minStart = Long.MaxValue
    var maxFinish = 0L
    app.runQuery(
      s"""
         | select
         | host,
         | executorId,
         | stageId,
         | taskId,
         | launchTime,
         | finishTime,
         | duration
         | from taskDF_${app.index} order by host, executorId, launchTime
         | """.stripMargin).collect().foreach { row =>
      val host = row.getString(0)
      val execId = row.getString(1)
      val stageId = row.getInt(2)
      val taskId = row.getLong(3)
      val launchTime = row.getLong(4)
      val finishTime = row.getLong(5)
      val duration = row.getLong(6)
      val taskInfo = OccupancyTaskInfo(stageId, taskId, launchTime, finishTime, duration)
      val execToTaskList = hostToExecList.getOrElseUpdate(host,
        new mutable.TreeMap[String, ArrayBuffer[OccupancyTaskInfo]]())
      execToTaskList.getOrElseUpdate(execId, ArrayBuffer.empty) += taskInfo
      minStart = Math.min(launchTime, minStart)
      maxFinish = Math.max(finishTime, maxFinish)
      stageIdToColor.getOrElseUpdate(stageId, {
        val color = colors(colorIndex % colors.length)
        colorIndex += 1
        color
      })
    }
    val numSlots = hostToExecList.values.map(_.size).sum

    val fileWriter = new ToolTextFileWriter(outputDirectory,
      s"${app.appId}-occupancy.svg")
    try {
      val width = (maxFinish - minStart)/MS_PER_PIXEL + (HEADER_WIDTH * 2) + PADDING * 2
      val height = (numSlots * TASK_HEIGHT) + TITLE_HEIGHT
      // scalastyle:off line.size.limit
      fileWriter.write(
        s"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
           |<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
           | "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
           |<!-- Generated by Rapids Spark Profiling Tool -->
           |<svg width="${width}pt" height="${height}pt"
           | xmlns="http://www.w3.org/2000/svg">
           | <title>${app.appId} OCCUPANCY</title>
           |""".stripMargin)
      fileWriter.write(s"""<text x="$PADDING" y="${TITLE_HEIGHT/2}" dominant-baseline="middle" font-family="Courier,monospace" font-size="$FONT_SIZE">${app.appId} OCCUPANCY</text>\n""")
      var hostYStart = PADDING + TITLE_HEIGHT
      hostToExecList.foreach {
        case (host, execToTaskList) =>
          val numElements = execToTaskList.size
          val hostHeight = numElements * TASK_HEIGHT
          val hostMiddleY = hostHeight/2 + hostYStart
          // Draw a box for the Host
          fileWriter.write(
            s"""<rect x="$PADDING" y="$hostYStart" width="$HEADER_WIDTH" height="$hostHeight"
              | style="fill:white;fill-opacity:0.0;stroke:black;stroke-width:2"/>
              |<text x="${PADDING * 2}" y="$hostMiddleY" dominant-baseline="middle"
              | font-family="Courier,monospace" font-size="$FONT_SIZE">$host</text>
              |""".stripMargin)
          var slotYStart = hostYStart
          execToTaskList.foreach {
            case (execId, taskList) =>
              val slotXStart = PADDING + HEADER_WIDTH
              val slotXEnd = slotXStart + HEADER_WIDTH
              val slotMiddleY = TASK_HEIGHT/2 + slotYStart
              fileWriter.write(
                s"""<rect x="$slotXStart" y="$slotYStart" width="$HEADER_WIDTH" height="$TASK_HEIGHT"
                   | style="fill:white;fill-opacity:0.0;stroke:black;stroke-width:2"/>
                   |<text x="${slotXStart + PADDING}" y="$slotMiddleY" dominant-baseline="middle"
                   | font-family="Courier,monospace" font-size="$FONT_SIZE">$execId</text>
                   |""".stripMargin)
              taskList.foreach { taskInfo =>
                val taskXStart = slotXEnd + (taskInfo.launchTime - minStart)/MS_PER_PIXEL
                val taskWidth = (taskInfo.finishTime - taskInfo.launchTime)/MS_PER_PIXEL
                val color = stageIdToColor(taskInfo.stageId)
                fileWriter.write(
                  s"""<rect x="$taskXStart" y="$slotYStart" width="$taskWidth" height="$TASK_HEIGHT"
                     | style="fill:$color;fill-opacity:1.0;stroke:black;stroke-width:1"/>
                     |""".stripMargin)
              }
              slotYStart += TASK_HEIGHT
          }
          hostYStart += hostHeight
      }
      fileWriter.write(s"""</svg>""")
      // scalastyle:on line.size.limit
    } finally {
      fileWriter.close()
    }
  }
}
